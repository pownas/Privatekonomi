@page "/settings/data-management"
@page "/admin/data-management"
@page "/data-management"
@rendermode InteractiveServer
@inject ISnackbar Snackbar
@inject NavigationManager Navigation
@inject HttpClient Http
@inject IJSRuntime JS
@using System.Text.Json
@using Microsoft.Extensions.Options
@using Privatekonomi.Core.Configuration

<PageTitle>Datahantering - Privatekonomi</PageTitle>

<MudText Typo="Typo.h4" Class="mb-4">
    <MudIcon Icon="@Icons.Material.Filled.Backup" Color="Color.Primary" Class="mr-2" aria-hidden="true" />
    Datahantering
</MudText>

<MudText Typo="Typo.body1" Class="mb-6">
    Här kan du exportera, importera och spara din ekonomidata. Detta är användbart för backup, migrering mellan enheter och dataåterställning.
</MudText>

@* Export Section *@
<MudPaper Class="pa-6 mb-4">
    <MudText Typo="Typo.h5" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.FileDownload" Class="mr-2" />
        Exportera Data
    </MudText>
    
    <MudText Typo="Typo.body2" Class="mb-4">
        Skapa en fullständig backup av all din data i JSON-format. Denna fil kan senare importeras för att återställa din data.
    </MudText>
    
    <MudButton Variant="Variant.Filled" 
               Color="Color.Primary" 
               StartIcon="@Icons.Material.Filled.CloudDownload"
               OnClick="ExportFullBackup"
               Disabled="_exporting">
        @if (_exporting)
        {
            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
            <MudText Class="ml-2">Exporterar...</MudText>
        }
        else
        {
            <span>Exportera Full Backup</span>
        }
    </MudButton>
</MudPaper>

@* Year Export Section *@
<MudPaper Class="pa-6 mb-4">
    <MudText Typo="Typo.h5" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.CalendarToday" Class="mr-2" />
        Exportera per År
    </MudText>
    
    <MudText Typo="Typo.body2" Class="mb-4">
        Exportera ekonomisk data för ett specifikt år. Detta inkluderar transaktioner, budgetar, investeringar, lån och löneutveckling för det valda året.
    </MudText>
    
    @if (_loadingYears)
    {
        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
    }
    else if (!_availableYears.Any())
    {
        <MudAlert Severity="Severity.Info">
            Inga år med data tillgängliga. Lägg till transaktioner för att exportera data per år.
        </MudAlert>
    }
    else
    {
        <MudGrid>
            <MudItem xs="12" md="6">
                <MudSelect T="int?" @bind-Value="_selectedYear" Label="Välj år" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomCenter">
                    @foreach (var year in _availableYears)
                    {
                        <MudSelectItem Value="@((int?)year)">@year</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" md="6" Class="d-flex align-center">
                <MudButtonGroup Variant="Variant.Outlined" Color="Color.Primary">
                    <MudButton StartIcon="@Icons.Material.Filled.Download" 
                               OnClick="ExportYearToJson"
                               Disabled="!_selectedYear.HasValue || _exportingYear">
                        JSON
                    </MudButton>
                    <MudButton StartIcon="@Icons.Material.Filled.Download" 
                               OnClick="ExportYearToCsv"
                               Disabled="!_selectedYear.HasValue || _exportingYear">
                        CSV
                    </MudButton>
                </MudButtonGroup>
                @if (_exportingYear)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="ml-2" />
                }
            </MudItem>
        </MudGrid>
        
        @if (_selectedYear.HasValue)
        {
            <MudAlert Severity="Severity.Info" Class="mt-3">
                Exporterar data för år <strong>@_selectedYear.Value</strong>
            </MudAlert>
        }
    }
</MudPaper>

@* Import Section *@
<MudPaper Class="pa-6 mb-4">
    <MudText Typo="Typo.h5" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.FileUpload" Class="mr-2" />
        Importera Data
    </MudText>
    
    <MudText Typo="Typo.body2" Class="mb-4">
        Importera data från en tidigare exporterad backup-fil. 
        <strong>Varning:</strong> Detta kommer ersätta all befintlig data om inte sammanfogningsläget används.
    </MudText>
    
    <MudFileUpload T="IBrowserFile" FilesChanged="OnImportFileSelected" Accept=".json">
        <ActivatorContent>
            <MudPaper Outlined="true" Class="pa-8 d-flex flex-column align-center justify-center" Style="min-height: 150px; cursor: pointer;">
                <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Large" Class="mb-2" />
                <MudText Typo="Typo.h6">Välj backup-fil (.json)</MudText>
                <MudButton Variant="Variant.Filled" Color="Color.Secondary" Class="mt-2">
                    Välj fil
                </MudButton>
            </MudPaper>
        </ActivatorContent>
    </MudFileUpload>
    
    @if (_importFile != null)
    {
        <MudAlert Severity="Severity.Info" Class="mt-4">
            Vald fil: <strong>@_importFile.Name</strong> (@FormatFileSize(_importFile.Size))
        </MudAlert>
        
        <div class="mt-4">
            <MudCheckBox @bind-Value="_mergeMode" Color="Color.Primary">
                Sammanfoga med befintlig data (behåller befintlig data och lägger till ny)
            </MudCheckBox>
        </div>
        
        <MudAlert Severity="@(_mergeMode ? Severity.Warning : Severity.Error)" Class="mt-2">
            @if (_mergeMode)
            {
                <MudText><strong>Sammanfogningsläge:</strong> Befintlig data behålls och ny data läggs till.</MudText>
            }
            else
            {
                <MudText><strong>Ersättningsläge:</strong> All befintlig data kommer att raderas och ersättas med data från backup-filen!</MudText>
            }
        </MudAlert>
        
        <MudButton Variant="Variant.Filled" 
                   Color="Color.Primary" 
                   StartIcon="@Icons.Material.Filled.Upload"
                   OnClick="ImportBackup"
                   Disabled="_importing"
                   Class="mt-4">
            @if (_importing)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                <MudText Class="ml-2">Importerar...</MudText>
            }
            else
            {
                <span>Importera Backup</span>
            }
        </MudButton>
    }
    
    <MudText Typo="Typo.caption" Class="mt-4">
        Tillåtna format: .json<br/>
        Max storlek: 50 MB
    </MudText>
</MudPaper>

@* Manual Save Section (only for JsonFile provider) *@
@if (_storageProvider == "JsonFile")
{
    <MudPaper Class="pa-6 mb-4">
        <MudText Typo="Typo.h5" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Save" Class="mr-2" />
            Manuell Sparning
        </MudText>
        
        <MudText Typo="Typo.body2" Class="mb-4">
            Data sparas automatiskt var 5:e minut när du använder JsonFile-lagring. 
            Du kan också spara manuellt direkt genom att klicka på knappen nedan.
        </MudText>
        
        <MudButton Variant="Variant.Filled" 
                   Color="Color.Success" 
                   StartIcon="@Icons.Material.Filled.Save"
                   OnClick="ManualSave"
                   Disabled="_saving">
            @if (_saving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                <MudText Class="ml-2">Sparar...</MudText>
            }
            else
            {
                <span>Spara Nu</span>
            }
        </MudButton>
        
        @if (_lastSaveTime.HasValue)
        {
            <MudText Typo="Typo.caption" Class="mt-2">
                Senast sparad: @_lastSaveTime.Value.ToString("yyyy-MM-dd HH:mm:ss")
            </MudText>
        }
    </MudPaper>
}

@* Info Section *@
<MudPaper Class="pa-6">
    <MudText Typo="Typo.h6" Class="mb-3">Information</MudText>
    
    <MudText Typo="Typo.body2" Class="mb-2">
        <strong>Nuvarande lagringsprovider:</strong> @_storageProvider
    </MudText>
    
    @if (_storageProvider == "JsonFile")
    {
        <MudAlert Severity="Severity.Info" Class="mt-3">
            <MudText>Du använder JsonFile-lagring med automatisk sparning var 5:e minut.</MudText>
        </MudAlert>
    }
    else if (_storageProvider == "Sqlite" || _storageProvider == "SqlServer")
    {
        <MudAlert Severity="Severity.Success" Class="mt-3">
            <MudText>Du använder @_storageProvider-lagring. Data sparas automatiskt och permanent.</MudText>
        </MudAlert>
    }
    else if (_storageProvider == "InMemory")
    {
        <MudAlert Severity="Severity.Warning" Class="mt-3">
            <MudText>Du använder InMemory-lagring för utveckling. Data sparas INTE permanent och försvinner vid omstart!</MudText>
        </MudAlert>
    }
</MudPaper>

@code {
    private bool _exporting = false;
    private bool _importing = false;
    private bool _saving = false;
    private IBrowserFile? _importFile = null;
    private bool _mergeMode = false;
    private DateTime? _lastSaveTime = null;
    private string _storageProvider = "Unknown";
    
    // Year export fields
    private bool _loadingYears = true;
    private bool _exportingYear = false;
    private List<int> _availableYears = new();
    private int? _selectedYear = null;

    [Inject]
    private IOptions<StorageSettings>? StorageSettings { get; set; }
    
    [Inject]
    private IExportService? ExportService { get; set; }

    protected override async Task OnInitializedAsync()
    {
        _storageProvider = StorageSettings?.Value?.Provider ?? "Unknown";
        await LoadAvailableYears();
    }

    private async Task LoadAvailableYears()
    {
        _loadingYears = true;
        StateHasChanged();
        
        try
        {
            if (ExportService != null)
            {
                _availableYears = await ExportService.GetAvailableYearsAsync();
                if (_availableYears.Any())
                {
                    _selectedYear = _availableYears.First(); // Select most recent year by default
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Kunde inte ladda tillgängliga år: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingYears = false;
            StateHasChanged();
        }
    }

    private async Task ExportYearToJson()
    {
        if (!_selectedYear.HasValue || ExportService == null)
            return;

        _exportingYear = true;
        StateHasChanged();

        try
        {
            var data = await ExportService.ExportYearDataToJsonAsync(_selectedYear.Value);
            var fileName = $"privatekonomi_{_selectedYear.Value}.json";
            var base64 = Convert.ToBase64String(data);
            
            await JS.InvokeVoidAsync("downloadFile", fileName, "application/json", base64);
            Snackbar.Add($"Data för år {_selectedYear.Value} exporterades som JSON!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Ett fel uppstod vid export: {ex.Message}", Severity.Error);
        }
        finally
        {
            _exportingYear = false;
            StateHasChanged();
        }
    }

    private async Task ExportYearToCsv()
    {
        if (!_selectedYear.HasValue || ExportService == null)
            return;

        _exportingYear = true;
        StateHasChanged();

        try
        {
            var data = await ExportService.ExportYearDataToCsvAsync(_selectedYear.Value);
            var fileName = $"privatekonomi_{_selectedYear.Value}.csv";
            var base64 = Convert.ToBase64String(data);
            
            await JS.InvokeVoidAsync("downloadFile", fileName, "text/csv", base64);
            Snackbar.Add($"Data för år {_selectedYear.Value} exporterades som CSV!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Ett fel uppstod vid export: {ex.Message}", Severity.Error);
        }
        finally
        {
            _exportingYear = false;
            StateHasChanged();
        }
    }

    private async Task ExportFullBackup()
    {
        _exporting = true;
        StateHasChanged();

        try
        {
            var fileName = $"privatekonomi_backup_{DateTime.Now:yyyyMMdd_HHmmss}.json";
            
            // Get API base URL from configuration or use default
            var apiBaseUrl = Navigation.BaseUri.TrimEnd('/');
            var response = await Http.GetAsync($"{apiBaseUrl}/api/export/backup");

            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsByteArrayAsync();
                var base64 = Convert.ToBase64String(content);
                
                // Download file using JS interop
                await JS.InvokeVoidAsync("downloadFile", fileName, "application/json", base64);
                
                Snackbar.Add("Backup exporterad framgångsrikt!", Severity.Success);
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Fel vid export: {error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Ett fel uppstod: {ex.Message}", Severity.Error);
        }
        finally
        {
            _exporting = false;
            StateHasChanged();
        }
    }

    private void OnImportFileSelected(IBrowserFile file)
    {
        _importFile = file;
        StateHasChanged();
    }

    private async Task ImportBackup()
    {
        if (_importFile == null)
            return;

        _importing = true;
        StateHasChanged();

        try
        {
            // Create multipart form content
            using var content = new MultipartFormDataContent();
            
            var fileContent = new StreamContent(_importFile.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024));
            fileContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/json");
            content.Add(fileContent, "file", _importFile.Name);
            content.Add(new StringContent(_mergeMode.ToString()), "mergeMode");

            var apiBaseUrl = Navigation.BaseUri.TrimEnd('/');
            var response = await Http.PostAsync($"{apiBaseUrl}/api/export/backup/import", content);

            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadAsStringAsync();
                var jsonDoc = JsonDocument.Parse(result);
                
                if (jsonDoc.RootElement.TryGetProperty("message", out var messageElement))
                {
                    Snackbar.Add(messageElement.GetString() ?? "Import lyckades", Severity.Success);
                }
                
                // Show imported counts
                if (jsonDoc.RootElement.TryGetProperty("importedCounts", out var countsElement))
                {
                    var counts = JsonSerializer.Deserialize<Dictionary<string, int>>(countsElement.GetRawText());
                    if (counts != null && counts.Any())
                    {
                        var countSummary = string.Join(", ", counts.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
                        Snackbar.Add($"Importerat: {countSummary}", Severity.Info);
                    }
                }

                // Reset file selection
                _importFile = null;
                _mergeMode = false;
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Fel vid import: {error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Ett fel uppstod: {ex.Message}", Severity.Error);
        }
        finally
        {
            _importing = false;
            StateHasChanged();
        }
    }

    private async Task ManualSave()
    {
        _saving = true;
        StateHasChanged();

        try
        {
            var apiBaseUrl = Navigation.BaseUri.TrimEnd('/');
            var response = await Http.PostAsync($"{apiBaseUrl}/api/export/save", null);

            if (response.IsSuccessStatusCode)
            {
                _lastSaveTime = DateTime.Now;
                Snackbar.Add("Data sparades framgångsrikt!", Severity.Success);
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Fel vid sparning: {error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Ett fel uppstod: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}

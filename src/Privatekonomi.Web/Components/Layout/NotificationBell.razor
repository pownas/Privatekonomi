@using Privatekonomi.Core.Models
@using Privatekonomi.Core.Services
@using Microsoft.AspNetCore.SignalR.Client
@inject INotificationService NotificationService
@inject ICurrentUserService CurrentUserService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@implements IAsyncDisposable

<MudBadge Content="@_unreadCount" 
          Overlap="true" 
          Color="Color.Error" 
          Visible="@(_unreadCount > 0)">
    <MudIconButton Icon="@Icons.Material.Filled.Notifications" 
                   Color="Color.Inherit" 
                   OnClick="NavigateToNotifications"
                   aria-label="Notifikationer" />
</MudBadge>

@code {
    private int _unreadCount = 0;
    private HubConnection? _hubConnection;

    protected override async Task OnInitializedAsync()
    {
        await UpdateUnreadCount();
        await InitializeSignalR();
    }

    private async Task InitializeSignalR()
    {
        try
        {
            var userId = CurrentUserService.UserId;
            if (userId == null)
            {
                return;
            }

            // Build the hub connection
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/notificationHub"))
                .WithAutomaticReconnect()
                .Build();

            // Handle incoming notifications
            _hubConnection.On<Notification>("ReceiveNotification", async (notification) =>
            {
                await InvokeAsync(() =>
                {
                    _unreadCount++;
                    
                    // Show toast notification
                    var severity = GetSeverity(notification.Priority);
                    Snackbar.Add(notification.Message, severity, config =>
                    {
                        config.VisibleStateDuration = 5000;
                        config.ShowCloseIcon = true;
                    });
                    
                    StateHasChanged();
                });
            });

            // Handle unread count updates
            _hubConnection.On<int>("UpdateUnreadCount", async (count) =>
            {
                await InvokeAsync(() =>
                {
                    _unreadCount = count;
                    StateHasChanged();
                });
            });

            // Handle reconnection
            _hubConnection.Reconnecting += error =>
            {
                Console.WriteLine($"Connection lost. Reconnecting... Error: {error?.Message}");
                return Task.CompletedTask;
            };

            _hubConnection.Reconnected += async connectionId =>
            {
                Console.WriteLine($"Reconnected with connection ID: {connectionId}");
                await UpdateUnreadCount();
            };

            // Start the connection
            await _hubConnection.StartAsync();
            Console.WriteLine("SignalR connection established for notifications");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing SignalR: {ex.Message}");
        }
    }

    private async Task UpdateUnreadCount()
    {
        try
        {
            var userId = CurrentUserService.UserId;
            if (userId != null)
            {
                _unreadCount = await NotificationService.GetUnreadCountAsync(userId);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating unread count: {ex.Message}");
        }
    }

    private void NavigateToNotifications()
    {
        NavigationManager.NavigateTo("/notifications");
    }

    private Severity GetSeverity(NotificationPriority priority)
    {
        return priority switch
        {
            NotificationPriority.Critical => Severity.Error,
            NotificationPriority.High => Severity.Warning,
            NotificationPriority.Normal => Severity.Info,
            NotificationPriority.Low => Severity.Info,
            _ => Severity.Normal
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}
